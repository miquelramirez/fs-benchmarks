(define (problem sample)
  (:domain fn-n-puzzle-nested)

  (:objects)

  (:init
   ;; the static 'next' function (of course we would prefer to have
   ;; this as part of the domain definition, but what can you do?)
   (= (next up 0) 0)
   (= (next up 1) 0)
   (= (next up 2) 0)
   (= (next up 3) 0)
   (= (next up 4) 1)
   (= (next up 5) 2)
   (= (next up 6) 3)
   (= (next up 7) 4)
   (= (next up 8) 5)
   (= (next up 9) 6)
   (= (next down 0) 0)
   (= (next down 1) 4)
   (= (next down 2) 5)
   (= (next down 3) 6)
   (= (next down 4) 7)
   (= (next down 5) 8)
   (= (next down 6) 9)
   (= (next down 7) 0)
   (= (next down 8) 0)
   (= (next down 9) 0)
   (= (next left 0) 0)
   (= (next left 1) 0)
   (= (next left 2) 1)
   (= (next left 3) 2)
   (= (next left 4) 0)
   (= (next left 5) 4)
   (= (next left 6) 5)
   (= (next left 7) 0)
   (= (next left 8) 7)
   (= (next left 9) 8)
   (= (next right 0) 0)
   (= (next right 1) 2)
   (= (next right 2) 3)
   (= (next right 3) 0)
   (= (next right 4) 5)
   (= (next right 5) 6)
   (= (next right 6) 0)
   (= (next right 7) 8)
   (= (next right 8) 9)
   (= (next right 9) 0)

   ;; the actual initial state
   (= (blank) 1)
   (= (tile_at 1) 0)
   (= (tile_at 2) 1)
   (= (tile_at 3) 2)
   (= (tile_at 4) 3)
   (= (tile_at 5) 4)
   (= (tile_at 6) 5)
   (= (tile_at 7) 6)
   (= (tile_at 8) 7)
   (= (tile_at 9) 8)
   )

  (:goal (and (= (tile_at 1) 8)
	      (= (tile_at 2) 7)
	      (= (tile_at 3) 6)
	      (= (tile_at 5) 4)
	      (= (tile_at 6) 1)
	      (= (tile_at 7) 2)
	      (= (tile_at 8) 5)
	      (= (tile_at 9) 3)))

  (:bounds
    (tile - int[0..8])
    (position - int[0..9])
  )

)
